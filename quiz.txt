**1. Procesor Intel 4004 powstał w roku**
a) 1965
b) 1972
c) 1978
d) 1981
e) żadne z powyższych
**Poprawna odpowiedź:**
e) żadne z powyższych**  
**Wyjaśnienie:** Procesor Intel 4004 został wypuszczony na rynek w 1971 roku [2].
**2. Ile rejestrów posiadał procesor 4004**
a) 4 rejestry 4 bitowe
b) 8 rejestrów 4 bitowych
c) 4 rejestry 8 bitowe
d) 16 rejestrów 4 bitowych
e) żadne z powyższych
**Poprawna odpowiedź:**
d) 16 rejestrów 4 bitowych**  
**Wyjaśnienie:** Intel 4004 posiadał 16 4-bitowych rejestrów [3]. Opcja "d" została dodana, aby odzwierciedlić faktyczną liczbę rejestrów, ponieważ żadna z pierwotnie podanych opcji (a, b,
c) nie była poprawna.
**3. Procesory Intel 8080 mogły adresować pamięć o rozmiarze**
a) 4 KiB
b) 14 KiB
c) 1 MiB
d) 16 MiB
e) żadne z powyższych
**Poprawna odpowiedź:**
e) żadne z powyższych**  
**Wyjaśnienie:** Procesory Intel 8080 mogły adresować maksymalnie do 64 KiB pamięci [3].
**4. Intel 8080 był pierwotnie opracowany do**
a) kalkulatora
b) terminala komputerowego
c) samolotu F14
d) sterowania 4-stopniowym ramieniem
e) żadne z powyższych
**Poprawna odpowiedź:**
e) żadne z powyższych**  
**Wyjaśnienie:** Intel 8080 został zaprojektowany z myślą o ogólnym przeznaczeniu [3]. Chociaż Intel 4004 był pierwotnie przeznaczony do kalkulatorów [4], dla procesora 8080 nie podano konkretnego pierwotnego przeznaczenia spośród opcji.
**5. Głównym konstruktorem procesora 8086 był**
a) Steve Baimer
b) Steve Jobs
c) Steven Morse
d) Bill Gates
e) żadne z powyższych
**Poprawna odpowiedź:**
e) żadne z powyższych**  
**Wyjaśnienie:** Źródła nie wskazują głównego konstruktora procesora 8086. Stwierdzono jedynie, że "Gdyby szefostwo Intela chciało, by architektura ta przetrwała wiele generacji i przerodziła się w dzisiejsze procesory, to nigdy nie zleciliby tego zadania jednej osobie" [5].
**6. Komputer IBM 5150 posiadał procesor Intel**
a) 8080
b) 8086
c) 8088
d) 80186
e) żaden z powyższych
**Poprawna odpowiedź:**
c) 8088**  
**Wyjaśnienie:** Komputer IBM 5150 posiadał procesor Intel 8088, pomimo że na rynku był dostępny mocniejszy procesor 8086 [5].
**7. Który z procesorów jako pierwszy mógł współpracować z koprocesorem**
a) 8088
b) 80286
c) 80386
d) 80486DX
e) Pentium Pro
**Poprawna odpowiedź:**
a) 8088**  
**Wyjaśnienie:** Pierwszym procesorem, który mógł współpracować z koprocesorem (model 8087), był 8088 [6].
**8. Ile instrukcji może przechowywać kolejka instrukcji procesora 8088**
a) 2
b) 4
c) 6
d) 8
e) 16
**Poprawna odpowiedź:**
b) 4**  
**Wyjaśnienie:** Procesor Intel 8088 posiadał kolejkę instrukcji 4-elementową, w przeciwieństwie do swojego poprzednika 8086, który posiadał 6-elementową [7].
**9. W którym procesorze Intel po raz pierwszy zastosował tryb chroniony**
a) 8086
b) 80286
c) 80386
d) Pentium Pro
e) żadne z powyższych
**Poprawna odpowiedź:**
b) 80286**  
**Wyjaśnienie:** Tryb chroniony został wprowadzony w 1982 roku do procesora 80286. Tryb ten umożliwiał adresowanie pamięci powyżej 1 MB oraz wprowadzał sprzętową ochronę pamięci, stronicowanie i wywłaszczanie procesów [7, 8].
**10. Procesory Intel 80286 mogły zaadresować pamięć o rozmiarze**
a) 4 KiB
b) 16 KiB
c) 1 MiB
d) 16 MiB
e) żadne z powyższych
**Poprawna odpowiedź:**
d) 16 MiB**  
**Wyjaśnienie:** Procesor Intel 80286 wprowadził tryb chroniony, w którym mógł zaadresować do 16 MiB pamięci. W trybie rzeczywistym mógł adresować tylko 1 MiB [8].
**11. W procesorze i486SX Intel po raz pierwszy wprowadził**
a) rejestry 32-bitowe
b) pięciostopniowy potok instrukcji
c) koprocesor matematyczny
d) brak poprawnej odpowiedzi
e) żadne z powyższych
**Poprawna odpowiedź:**
e) żadne z powyższych**  
**Wyjaśnienie:** Rejestry 32-bitowe zostały wprowadzone w i386, natomiast koprocesor matematyczny i pięciostopniowy potok instrukcji zostały wprowadzone w i486DX, a nie w i486SX [9, 10]. Dlatego żadna z podanych opcji nie jest poprawna dla i486SX.
**12. Dwa rdzenie po raz pierwszy pojawiły się w procesorze**
a) Pentium
b) Pentium II
c) Pentium III
d) Pentium IV
e) Core 2 Duo
**Poprawna odpowiedź:**
d) Pentium IV**  
**Wyjaśnienie:** Dwa rdzenie po raz pierwszy pojawiły się w wersjach Smithfield i Presler, wydanych w 2005 roku, pod koniec produkcji procesorów Pentium IV, na rok przed wypuszczeniem Core 2 Duo [10].
**13. Superskalarność to właściwość procesora polegająca na**
a) wykonywaniu instrukcji w potoku
b) wykonywaniu kilku instrukcji jednocześnie
c) przewidywaniu, który rozkaz będzie wykonywany po skoku warunkowym
d) redukcji liczby rozkazów
e) żadna z powyższych
**Poprawna odpowiedź:**
b) wykonywaniu kilku instrukcji jednocześnie**  
**Wyjaśnienie:** Superskalarność to cecha procesorów oznaczająca możliwość wykonywania kilku instrukcji (rozkazów maszynowych) jednocześnie, uzyskiwana poprzez zwielokrotnienie jednostek wykonawczych [10].
**14. W procesorze Sandy Bridge pojawiły się instrukcje**
a) MMX
b) SSE
c) AVX
d) FMA3
e) brak poprawnej odpowiedzi
**Poprawna odpowiedź:**
c) AVX**  
**Wyjaśnienie:** Druga generacja procesorów Intel (Sandy Bridge) wprowadziła instrukcje AVX [11].
**15. Instrukcje FMA3 po raz pierwszy zostały wbudowane do procesora**
a) Sandy Bridge
b) Ivy Bridge
c) Hashwell
d) Sky Lake
e) żadne z powyższych
**Poprawna odpowiedź:**
c) Hashwell**  
**Wyjaśnienie:** Czwarta generacja procesorów Intel (Hashwell) wprowadziła instrukcje FMA3 oraz AVX2 [11].
**16. Procesory Core 2 Duo posiadają współczynnik IPC (Instruction Per Cycle)**
a) 4
b) 3,5
c) 2,5
d) 2
e) 3
**Poprawna odpowiedź:**
e) 3**  
**Wyjaśnienie:** Wartość IPC w procesorach z ostatnich 30 lat waha się ogólnie od 3 do 4 [12]. Opcja "3" jest wartością w tym zakresie.
**17. Instrukcje SSE Intel wprowadził po raz pierwszy w procesorze**
a) Ivy Bridge
b) Sandy Bridge
c) Core 2 Duo
d) Pentium III
e) Pentium MMX
**Poprawna odpowiedź:** **Brak bezpośredniej odpowiedzi w źródłach.**  
**Wyjaśnienie:** Źródła nie zawierają bezpośredniej informacji o tym, który procesor jako pierwszy wprowadził instrukcje SSE. Wskazano jedynie, że "Pentium MMX (...) wprowadził instrukcje" [12], ale zdanie to jest niekompletne.
**18. Instrukcje AVX Intel wprowadził po raz pierwszy w procesorze**
a) Pentium II
b) Pentium 4
c) Pentium D
d) Sandy Bridge
e) Ivy Bridge
**Poprawna odpowiedź:**
d) Sandy Bridge**  
**Wyjaśnienie:** Instrukcje AVX wprowadzono w drugiej generacji procesorów Intel (Sandy Bridge) [11, 13].
**19. W procesorze Ivy Bridge Intel po raz pierwszy wprowadził**
a) rejestry 64-bitowe
b) pięciostopniowy potok instrukcji
c) koprocesor matematyczny
d) generator liczb losowych
e) żadne z powyższych
**Poprawna odpowiedź:**
d) generator liczb losowych**  
**Wyjaśnienie:** W trzeciej generacji procesorów Intel (Ivy Bridge) wprowadzono generator liczb losowych na bazie szumów termicznych procesora [13].
**20. 128 MiB pamięci podręcznej eDRAM posiadał procesor**
a) Coffee Lake
b) Broadwell
c) Hashwell
d) Sandy Bridge
e) nie było takiej pamięci
**Poprawna odpowiedź:** **Wiele poprawnych odpowiedzi lub pytanie błędne.**  
**Wyjaśnienie:** Zgodnie ze źródłem, jest to "błędne pytanie", ponieważ "wszystkie powyższe procesory, poza Sandy Bridge, posiadały eDRAM w wariancie 128 MiB" [13]. Oznacza to, że Coffee Lake, Broadwell i Haswell mogły posiadać taką pamięć.
**21. W procesorze Alder Lake Intel po raz pierwszy wprowadził**
a) rejestry 64-bitowe
b) pięciostopniowy potok instrukcji
c) koprocesor matematyczny
d) dwa rodzaje rdzeni
e) generator liczb losowych
**Poprawna odpowiedź:**
d) dwa rodzaje rdzeni**  
**Wyjaśnienie:** W 12. generacji procesorów Intel (Alder Lake) po raz pierwszy wprowadzono hybrydową architekturę z podziałem na wydajne rdzenie P i energooszczędne rdzenie E [14-16].
**22. Współczesne procesory Intel i3 zbudowane są z około**
a) kilku milionów tranzystorów
b) kilkudziesięciu milionów tranzystorów
c) kilkuset milionów tranzystorów
d) kilku miliardów tranzystorów
e) żadne z powyższych
**Poprawna odpowiedź:**
d) kilku miliardów tranzystorów**  
**Wyjaśnienie:** Współczesne procesory mają liczbę tranzystorów idącą w miliardy / dziesiątki miliardów. Przykładem jest i7 10. generacji, który posiadał 7,4 mld tranzystorów [17-19].
**23. Współczesne procesory Intel i7 zbudowane są z około**
a) 100 tys. tranzystorów
b) 1 mln tranzystorów
c) 10 mln tranzystorów
d) 100 mln tranzystorów
e) żadne z powyższych
**Poprawna odpowiedź:**
e) żadne z powyższych**  
**Wyjaśnienie:** Współczesne procesory mają liczbę tranzystorów idącą w miliardy / dziesiątki miliardów. Ostatni wspomniany w wykładzie i7 10. generacji posiadał 7,4 mld tranzystorów, co znacznie przewyższa podane opcje [17, 18].
**24. Liczba tranzystorów we współczesnych procesorach Intela jest rzędu**
a) 10^5
b) 10^7
c) 10^9
d) 10^11
e) żadne z powyższych
**Poprawna odpowiedź:**
c) 10^9**  
**Wyjaśnienie:** Współczesne procesory mają liczbę tranzystorów idącą w miliardy / dziesiątki miliardów [17-19]. Rząd wielkości 10^9 odpowiada miliardom.
**25. Ile rejestrów xmm posiadają w trybie EM64T procesory Intel**
a) 8
b) 16
c) 32
d) 64
e) nie ma takich rejestrów
**Poprawna odpowiedź:**
b) 16**  
**Wyjaśnienie:** W trybie EM64T procesory Intel posiadają 16 rejestrów xmm. W trybie IA-32 jest ich 8, a przy AVX512 liczba ta wzrasta do 32 [19].
**26. Ile rejestrów ymm używają w trybie x86 procesory intel**
a) 8
b) 16
c) 32
d) 64
e) nie ma takich rejestrów
**Poprawna odpowiedź:**
a) 8**  
**Wyjaśnienie:** W trybie x86 procesory Intel mają dostęp do 8 rejestrów ymm [20].
**27. Ile rejestrów ogólnego przeznaczenia dodał Intel w trybie EM64T do procesorów**
a) 8
b) 16
c) 32
d) 64
e) nie dodał
**Poprawna odpowiedź:**
a) 8**  
**Wyjaśnienie:** Intel w trybie EM64T dodał 8 nowych rejestrów ogólnego przeznaczenia (r8-r15) [20].
**28. Ile rejestrów segmentowych występuje w trybie IA-32 procesorów Intel**
a) 2
b) 4
c) 6
d) 8
e) żadne z wymienionych
**Poprawna odpowiedź:**
c) 6**  
**Wyjaśnienie:** W trybie IA-32 (a także w EM64T) występuje 6 rejestrów segmentowych: cs, ds, es, ss, fs, gs [20].
**29. Do odwołanie się do zmiennych lokalnych podprogramu stosuje się segment wskazany przez rejestr**
a) cs
b) ds
c) es
d) ss
e) gs
**Poprawna odpowiedź:**
b) ds**  
**Wyjaśnienie:** W segmencie `ds` znajdują się m.in. zmienne lokalne [21].
**30. Do odwołania się do zmiennych lokalnych stosuje się rejestr**
a) eax
b) ebx
c) ebp
d) esi
e) ds
**Poprawna odpowiedź:**
c) ebp**  
**Wyjaśnienie:** Rejestr `ebp` (base pointer) jest powszechnie używany jako wskaźnik do ramki stosu, gdzie przechowywane są zmienne lokalne. Chociaż źródło wspomina "edp" jako wskaźnik wierzchołka stosu [21], `ebp` jest typowym rejestrem dla zmiennych lokalnych.
**31. Rejestry mmx są**
a) częścią rejestrów xmm
b) częścią rejestrów ymm
c) oddzielnymi rejestrami
d) częścią rejestrów koprocesora
e) żadne z powyższych
**Poprawna odpowiedź:**
d) częścią rejestrów koprocesora**  
**Wyjaśnienie:** Rejestry MMX to 64-bitowe rejestry, które są współdzielone z rejestrami koprocesora (FPU). Korzystają z tych samych fizycznych zasobów w procesorze [22].
**32. Które rejestry (64-bitowe) są używane do przekazywania parametrów**
a) rax, rbx, rcx, rdx
b) rbx, rcx, r6, xmm0
c) r8, r9, r10, r11
d) rdx, rbx, e10, r11
e) xmm0, rdx, r8, r9
**Poprawna odpowiedź:**
e) xmm0, rdx, r8, r9**  
**Wyjaśnienie:** W trybie 64-bitowym rejestry `rcx`, `rdx`, `r8`, `r9` oraz `xmm0-xmm3` służą do przekazania pierwszych 4 argumentów [23]. Opcja "e" zawiera podzbiór tych rejestrów.
**33. Parametry aktualne przechowuje się w segmencie**
a) cs
b) ds
c) es
d) ss
e) fs
**Poprawna odpowiedź:**
b) ds**  
**Wyjaśnienie:** Rejestr `ds` służy do przechowywania aktualnych parametrów programu [23].
**34. W którym trybie adresowania adres w pamięci zawiera się w kodzie rozkazu**
a) bezpośrednim
b) rejestrowym
c) natychmiastowym
d) we wszystkich powyższych
e) w żadnym w powyższych
**Poprawna odpowiedź:**
a) bezpośrednim**  
**Wyjaśnienie:** W trybie bezpośrednim operandem jest adres pamięci (wskaźnik), który zawiera się w kodzie rozkazu [24].
**35. Prosty tryb adresowania występuje w instrukcji**
a) inc ecx
b) mov edi, offset zmienna
c) mov zmienna, edx
d) or edx, [ebx]
e) mov [edi * 8 + tablica], edx
**Poprawna odpowiedź:**
b) mov edi, offset zmienna**  
**Wyjaśnienie:** W trybie prostym (natychmiastowym) instrukcja jako argument dostaje stałą wartość. `offset zmienna` od razu przekazuje adres do instrukcji, co jest przykładem trybu natychmiastowego [25].
**36. Indeksowy tryb adresowania występuje w instrukcji**
a) inc ecx
b) mov edi, offset zmienna
c) mov zmienna, edx
d) or edx, [ebx]
e) mov [edi * 8 + tablica], edx
**Poprawna odpowiedź:**
e) mov [edi * 8 + tablica], edx**  
**Wyjaśnienie:** W instrukcji `mov [edi * 8 + tablica], edx` występuje tryb pośredni-indeksowy, gdzie `edi` pełni rolę indeksu [25].
**37. Pośredni bazowy tryb adresowania występuje w instrukcji**
a) inc
b) mov edi, offset zmienna
c) or edx, [ebx + tab]
d) mov [edi * 8 + tablica], edx
e) mov zmienna, edx
**Poprawna odpowiedź:**
c) or edx, [ebx + tab]**  
**Wyjaśnienie:** W trybie pośrednim bazowym operandem jest wskaźnik z przesunięciem, co jest widoczne w instrukcji `or edx, [ebx + tab]`, gdzie `ebx` jest bazą, a `tab` przesunięciem [25].
**38. Która instrukcja może zmienić rejestr cs**
a) xlatb
b) call
c) les
d) jnz
e) stc
**Poprawna odpowiedź:**
b) call**  
**Wyjaśnienie:** Instrukcja `call` wywołuje podprogram, co może spowodować zmianę segmentu kodu, a tym samym zmianę rejestru `cs` [26, 27].
**39. Instrukcja mov zmienia flagi**
a) ZF
b) SF
c) CF
d) wszystkie powyższe
e) żadne z powyższych
**Poprawna odpowiedź:**
e) żadne z powyższych**  
**Wyjaśnienie:** Instrukcja `mov` nie wpływa na flagi; przesyła tylko zawartość źródła do celu [26].
**40. Instrukcja dec zmienia flagi**
a) OZAPC
b) OSAPC
c) OSZPC
d) OSZAC
e) OSZAP
**Poprawna odpowiedź:**
e) OSZAP**  
**Wyjaśnienie:** Instrukcje `inc` i `dec` są jedynymi podstawowymi operacjami arytmetycznymi, które nie wpływają na flagę `CF`. Zmieniają flagi `OF`, `SF`, `ZF`, `AF`, `PF` [28].
**41. Która z instrukcji nie jest poprawna**
a) fsub
b) fsubp st, st(1)
c) fmulp st(4)
d) fsubr st(1), st
e) fsubrp st(1), st
**Poprawna odpowiedź:**
b) fsubp st, st(1)**  
**Wyjaśnienie:** Zgodnie ze źródłem, `fsubp st, st(1)` jest problematyczne, ponieważ po odejmowaniu zdejmuje liczbę z wierzchołka stosu, co może prowadzić do utraty wyniku [29]. `fsubrp` jest instrukcją poprawną [29].
**42. Która z instrukcji jest poprawna**
a) fmulp st(4)
b) fadd st(2), st(1)
c) fsubrp st(3), st
d) faddp st, st(2)
e) fsqrt st(1)
**Poprawna odpowiedź:**
c) fsubrp st(3), st**  
**Wyjaśnienie:** Instrukcja `fsubrp` jest poprawna, podczas gdy pozostałe funkcje mają nieprawidłową składnię, liczbę argumentów lub błąd logiczny [29].
**43. Do wydobycia najmłodszego bitu równego 1 służy instrukcja**
a) xgetbv
b) lzcnt
c) bextr
d) tzcnt
e) blsi
**Poprawna odpowiedź:**
e) blsi**  
**Wyjaśnienie:** Instrukcja `blsi` izoluje z rejestru najmłodszy bit równy 1 i umieszcza go w rejestrze celu [15, 29, 30].
**44. Która instrukcja sprawdza poprawność indeksu tablicy**
a) enter
b) bounds
c) check
d) bound
e) żadna z powyższych
**Poprawna odpowiedź:**
d) bound**  
**Wyjaśnienie:** Instrukcja `bound` służy do sprawdzania, czy wartość indeksu tablicy mieści się w określonych granicach. Jeśli indeks wykracza poza granice, zgłaszany jest wyjątek [30, 31].
**45. Która z instrukcji umożliwia dodawanie całkowite**
a) lea
b) sub
c) addx
d) faddi
e) żadna z powyższych
**Poprawna odpowiedź:**
a) lea**  
**Wyjaśnienie:** Instrukcja `lea` (load effective address) umożliwia różne operacje matematyczne, w tym dodawanie całkowite, np. `lea eax, [ebx + 4]` [31, 32].
**46. Która instrukcja operuje na rejestrze al**
a) xlatb
b) lss
c) movsxd
d) cli
e) żadna z powyższych
**Poprawna odpowiedź:**
a) xlatb**  
**Wyjaśnienie:** Instrukcja `xlatb` ma przypisane na stałe działanie na rejestrze `al` [31].
**47. Wykonanie instrukcji push [edx] / pop [ebx] odpowiadałoby instrukcji:**
a) xor [edx], [ebx]
b) xchg edx, ebx
c) fxch [edx], [ebx]
d) xchg [edx], [ebx]
e) żadne z powyższych
**Poprawna odpowiedź:**
e) żadne z powyższych**  
**Wyjaśnienie:** Żadna z podanych instrukcji nie odpowiada dokładnie działaniu `push [edx]` i `pop [ebx]`. Mimo że `xchg [edx], [ebx]` jest najbliżej, nie używa stosu [33].
**48. Która z instrukcji umożliwia dodanie trzech wartości**
a) add
b) xadd
c) iadd
d) lea
e) cwde
**Poprawna odpowiedź:**
d) lea**  
**Wyjaśnienie:** Instrukcja `lea` może być wykorzystana do dodawania trzech wartości, np. `lea eax, [ebx + ecx + edx]` [32].
**49. Która z instrukcji pozwala na podanie dwóch argumentów z pamięci**
a) mov
b) lods
c) stos
d) scas
e) żadna z powyższych
**Poprawna odpowiedź:**
e) żadna z powyższych**  
**Wyjaśnienie:** Instrukcja `mov` może przyjąć tylko jeden argument z pamięci, a instrukcje łańcuchowe (`lods`, `stos`, `scas`) są jednoargumentowe [34].
**50. Do policzenia starszych bitów równych 0 służy instrukcja**
a) bsf
b) lzcnt
c) btr
d) bextr
e) rdtsc
**Poprawna odpowiedź:**
b) lzcnt**  
**Wyjaśnienie:** Instrukcja `lzcnt` liczy liczbę wiodących (starszych) bitów równych 0 w liczbie zapisanej w rejestrze [35].
**51. Która z instrukcji tworzy ramę stosu**
a) push
b) call
c) enter
d) int
e) leave
**Poprawna odpowiedź:**
c) enter**  
**Wyjaśnienie:** Instrukcja `enter` tworzy ramę stosu [36].
**52. Przeszukiwanie bitów wstecz realizuje instrukcja**
a) bts
b) btr
c) btc
d) bsf
e) bsr
**Poprawna odpowiedź:**
e) bsr**  
**Wyjaśnienie:** Instrukcja `bsr` (bit scan reverse) przeszukuje bity wstecz [37].
**53. Która z instrukcji pozwala na poszukanie podanego znaku w tekście**
a) scasb
b) movsd
c) lodsw
d) cmpsb
e) stosw
**Poprawna odpowiedź:**
a) scasb**  
**Wyjaśnienie:** Instrukcja `scasb` porównuje zawartość akumulatora z wartością w pamięci pod adresem `es:edi`, co umożliwia przeszukiwanie tekstu w poszukiwaniu znaku [37].
**54. Która z instrukcji umożliwia wpisanie wartości do dwu rejestrów**
a) rcl
b) movbe
c) les
d) movbe
e) żadna z powyższych
**Poprawna odpowiedź:**
c) les**  
**Wyjaśnienie:** Źródło odnosi się do instrukcji `les` jako tej, która "wpisuje wartość do rejestru ds:arg1" [38], oraz "ładuje dane do dwóch rejestrów: rejestru ogólnego przeznaczenia oraz rejestru segmentowego es" [27, 35].
**55. Która z instrukcji nie jest poprawna**
a) fcmovne
b) fcmovnbe
c) fcmovnu
d) fcmovnb
e) fcmovl
**Poprawna odpowiedź:**
c) fcmovnu**  
**Wyjaśnienie:** Nie istnieje taka instrukcja jak `fcmovnu`. Pozostałe to poprawne instrukcje przesłania warunkowego dla liczb zmiennoprzecinkowych [38].
**56. Prefiks lock może odnosić się do instrukcji**
a) nop
b) xchg
c) cmp
d) mov
e) fdiv
**Poprawna odpowiedź:**
b) xchg**  
**Wyjaśnienie:** Prefiks `lock` może odnosić się do instrukcji `xchg` (oraz innych, takich jak `add`, `adc`, `and`, `btr`, `bts`, `cmpxchg`, `dec`, `inc`, `neg`, `not`, `or`, `sbb`, `sub`, `xor`, `xadd`) [4, 38, 39].
**57. Prefiks lock nie odnosi się do instrukcji**
a) lea
b) btr
c) xchg
d) cmpschg8b
e) neg
**Poprawna odpowiedź:**
a) lea**  
**Wyjaśnienie:** Instrukcja `lea` nie jest wymieniona na liście instrukcji, do których może odnosić się prefiks `lock` [39].
**58. Która z instrukcji zmienia flagę CF**
a) bswap
b) dec
c) cwd
d) fmul
e) fcomi
**Poprawna odpowiedź:**
e) fcomi**  
**Wyjaśnienie:** Instrukcja `fcomi` jest instrukcją porównującą, która wpływa na flagi procesora, w tym na flagę `CF` (Carry Flag) [39].
**59. Która z instrukcji nie zmienia flagi ZF**
a) ficom
b) neg
c) dec
d) cmp
e) xadd
**Poprawna odpowiedź:**
a) ficom**  
**Wyjaśnienie:** Instrukcja `ficom` porównuje liczby całkowite i wpływa na flagi koprocesora, a nie na flagi procesora, stąd nie zmienia flagi `ZF` (Zero Flag) [39, 40].
**60. Która z instrukcji nie zmienia flagi PF**
a) dec
b) cmp
c) paddd
d) xadd
e) fcomi
**Poprawna odpowiedź:**
c) paddd**  
**Wyjaśnienie:** Instrukcje MMX, takie jak `paddd`, nie wpływają na rejestr flag, w tym na flagę `PF` (Parity Flag) [40].
**61. Która z instrukcji nie zmienia flagi CF**
a) cmc
b) add
c) stc
d) clc
e) inc
**Poprawna odpowiedź:**
e) inc**  
**Wyjaśnienie:** Instrukcje `inc` i `dec` są jedynymi podstawowymi operacjami arytmetycznymi, które nie wpływają na flagę `CF` [41].
**62. Do prostego szyfrowania danych może służyć instrukcja**
a) movsd
b) btr
c) cwde
d) xlatb
e) les
**Poprawna odpowiedź:**
d) xlatb**  
**Wyjaśnienie:** Instrukcja `xlatb` dokonuje tłumaczenia w oparciu o tablicę translacji i może służyć do prostego szyfrowania [41].
**63. Która z instrukcji dla liczb ze znakiem przesyła dla warunku większości**
a) movg
b) movae
c) cmovnle
d) cmovnbe
e) cmpa
**Poprawna odpowiedź:**
c) cmovnle**  
**Wyjaśnienie:** Dla liczb ze znakiem, warunek "większości" (`greater`) jest równoważny warunkowi "nie mniejsze lub równe" (`nle`), co realizuje instrukcja `cmovnle` [42].
**64. Która instrukcja dla liczb bez znaku zamienia bajt na podwójne słowo**
a) xlatb
b) movzx
c) cbw
d) cbdw
e) bswap
**Poprawna odpowiedź:**
b) movzx**  
**Wyjaśnienie:** Instrukcja `movzx` przesyła źródło do celu z dopisaniem zer na starszych bitach, co efektywnie zamienia bajt na podwójne słowo bez zachowania znaku [42].
**65. Która z instrukcji wpisuje 1 do flagi CF**
a) stc
b) clc
c) cmc
d) cld
e) std
**Poprawna odpowiedź:**
a) stc**  
**Wyjaśnienie:** Instrukcja `stc` (set carry flag) ustawia flagę `CF` na 1 [42].
**66. Która instrukcja wpisuje 0 do flagi CF**
a) cmc
b) cld
c) stc
d) clc
e) std
**Poprawna odpowiedź:**
d) clc**  
**Wyjaśnienie:** Instrukcja `clc` (clear carry flag) zeruje flagę `CF` (wpisuje 0) [42, 43].
**67. Instrukcja fcomip zmienia flagi**
a) APC
b) OAC
c) OSZ
d) OZC
e) żadne z powyższych
**Poprawna odpowiedź:**
e) żadne z powyższych**  
**Wyjaśnienie:** Instrukcja `fcomip` wpływa na flagi procesora: `ZF` (Zero Flag), `PF` (Parity Flag) i `CF` (Carry Flag) [43]. Żadna z podanych opcji (`APC`, `OAC`, `OSZ`, `OZC`) nie odpowiada temu zestawowi flag.
**68. Instrukcja fcompp zmienia flagi**
a) APC
b) OAC
c) OSZ
d) OZC
e) żadne z powyższych
**Poprawna odpowiedź:**
a) APC**  
**Wyjaśnienie:** Instrukcja `fcompp` wpływa na flagi koprocesora: `C3`, `C2`, `C0` [44]. `APC` prawdopodobnie odnosi się do tych flag.
**69. Wykonując instrukcję push byte ptr [eax], procesor używa segmentów**
a) cs i ds
b) es i ds
c) ds i ss
d) ss i gs
e) fs i cs
**Poprawna odpowiedź:**
c) ds i ss**  
**Wyjaśnienie:** Instrukcja `push byte ptr [eax]` odwołuje się do segmentu `ds` ze względu na użycie `eax` (rejestry danych), a operacja `push` zawsze odnosi się do segmentu stosu (`ss`) [44].
**70. Instrukcja add al, 80h w programie neguje jakie flagi**
a) CF i PF
b) ZF i CF
c) AF i ZF
d) PF i SF
e) SF i CF
**Poprawna odpowiedź:**
e) SF i CF**  
**Wyjaśnienie:** Dodawanie liczby z ustawionym najbardziej znaczącym bitem (jak 80h) może spowodować przeniesienie (`CF`) oraz zmianę znaku (`SF`) [45].
**71. Po wykonaniu, której instrukcji zawartość al zmieni się z 0a5h na 5ah**
a) or al, 5ah
b) not al
c) rol al, 1
d) shl al, 1
e) mov 5ah, al
**Poprawna odpowiedź:**
b) not al**  
**Wyjaśnienie:** Wartość `0a5h` binarnie to `10100101`. Instrukcja `not al` neguje wszystkie bity, co daje `01011010` (czyli `5ah`) [45].
**72. Po wykonaniu instrukcji: mov eax, 0f0f0f0fh, mov edx, 87654321h, not ax, inc dx, and edx, eax rejestr edx będzie zawierał**
a) 07050301h
b) 80604020h
c) 07054020h
d) 80600301
e) 07054022
**Poprawna odpowiedź:**
c) 07054020h**  
**Wyjaśnienie:**
1.  `eax` = `0f0f0f0fh`
2.  `edx` = `87654321h`
3.  `not ax` zmienia `ax` (`0f0fh`) na `f0f0h`, więc `eax` = `0f0ff0f0h` [46].
4.  `inc dx` zmienia `dx` (`4321h`) na `4322h`, więc `edx` = `87654322h` [46].
5.  `and edx, eax` ( `87654322h` AND `0f0ff0f0h`) daje `07054020h` [46].
**73. Po wykonaniu instrukcji: mov ecx, 01020304h, mov eax, 87654321h, shr eax, cl, btr eax, 1 rejestr eax będzie zawierał:**
a) 08765432h
b) 0f8765432h
c) 043b2a190h
d) 0c3b2a190h
e) 08765430h
**Poprawna odpowiedź:**
e) 08765430h**  
**Wyjaśnienie:**
1.  `eax` = `87654321h`
2.  `shr eax, cl` (gdzie `cl` = `4`). `eax` = `08765432h` [47].
3.  `btr eax, 1` (testuje i zeruje bit 1). Bit 1 w `08765432h` jest ustawiony. Po operacji `eax` = `08765430h` [47].
**74. Podaj wartość eax po wykonaniu programu: mov al, 0c0h, movsx eax, al, mov ah, al, or eax, 11214181h, and eax, 0afbfcfdfh**
a) 0afbfcfdfh
b) 0a1b1c1d1h
c) 1112c1d1h
d) 0afbfc1c1h
e) 0a1b14f8fh
**Poprawna odpowiedź:**
d) 0afbfc1c1h**  
**Wyjaśnienie:**
1.  `mov al, 0c0h` -> `al` = `0c0h`
2.  `movsx eax, al` -> `eax` = `fffffc0h` [47]
3.  `mov ah, al` -> `eax` = `ffffc0c0h` [47]
4.  `or eax, 11214181h` -> `eax` = `ffffc1c1h` [47]
5.  `and eax, 0afbfcfdfh` -> `eax` = `0afbfc1c1h` [47]
**75. Po wykonaniu instrukcji: mov ecx, 11223344h, mov eax, 87654321h, shr eax, cl, bts eax, 0 rejestr eax będzie zawierał**
a) 08765433h
b) 08765432h
c) 043b2a190h
d) 0c3b2a190h
e) 021436587h
**Poprawna odpowiedź:**
a) 08765433h**  
**Wyjaśnienie:**
1.  `eax` = `87654321h`
2.  `shr eax, cl` (gdzie `cl` = `44h` mod 32, czyli `4`). `eax` = `08765432h` [47].
3.  `bts eax, 0` (testuje i ustawia bit 0). Bit 0 w `08765432h` jest zerowy. Po operacji `eax` = `08765433h` [47].
**76. Po wykonaniu instrukcji: mov edx, 159a01h, bsf eax, edx rejestr eax będzie zawierał:**
a) 00000001h
b) 00000014h
c) 00159a01h
d) 019a1500h
e) żadna z powyższych
**Poprawna odpowiedź:**
e) żadna z powyższych**  
**Wyjaśnienie:** Instrukcja `bsf` (bit scan forward) szuka najmłodszego bitu ustawionego na 1. Wartość `159a01h` ma bit 0 ustawiony, więc `eax` będzie zawierał `0`. Ponieważ `0` nie jest jedną z opcji, poprawną odpowiedzią jest "żadna z powyższych" [48, 49].
**77. Ile dodawań może maksymalnie zrealizować instrukcja AVX**
a) 64
b) 32
c) 16
d) 8
e) 4
**Poprawna odpowiedź:**
b) 32**  
**Wyjaśnienie:** Rejestry AVX (ymm) mają długość 256 bitów, co odpowiada 32 bajtom. Maksymalnie 32 dodawania na bajtach mogą być przeprowadzone jednocześnie [49].
**78. Do ilu bajtów wyrównania adresu wymaga instrukcja vmovdqu ymm4, tablica**
a) 32
b) 16
c) 8
d) 4
e) żadne z powyższych
**Poprawna odpowiedź:**
e) żadne z powyższych**  
**Wyjaśnienie:** Instrukcja `vmovdqu` jest zaprojektowana do pracy z niewyrównanymi adresami, dlatego nie wymaga konkretnego wyrównania [50].
**79. Ile bajtów zawiera się w rejestrach ymm**
a) 8
b) 16
c) 32
d) 256
e) żadne z powyższych
**Poprawna odpowiedź:**
c) 32**  
**Wyjaśnienie:** Rejestr `ymm` ma 256 bitów, co odpowiada 32 bajtom (256/8 = 32) [50].
**80. Do zmiany kolejności słów w rejestrze mmx służy instrukcja**
a) ldmxcsr
b) pmovmskb
c) cmovnge
d) psadbw
e) pshufw
**Poprawna odpowiedź:**
e) pshufw**  
**Wyjaśnienie:** Instrukcja `pshufw` służy do tasowania (zmiany kolejności) słów w rejestrze MMX [50].
**81. Pakowanie z nasyceniem podwójnych słów ze znakiem do słów realizuje instrukcja**
a) packsswb
b) packssdw
c) packusdw
d) packuswd
e) packsudw
**Poprawna odpowiedź:**
b) packssdw**  
**Wyjaśnienie:** Instrukcja `packssdw` realizuje pakowanie z nasyceniem podwójnych słów ze znakiem do słów [51].
**82. Która operacja konwertuje wektor liczb podwójnej precyzji na wektor liczb pojedynczej precyzji**
a) vcvtsd2ss
b) vcvtps2pd
c) vcvtpd2ps
d) vcvtsi2ss
e) żadna z powyższych
**Poprawna odpowiedź:**
c) vcvtpd2ps**  
**Wyjaśnienie:** Instrukcja `vcvtpd2ps` konwertuje wektor liczb zmiennoprzecinkowych podwójnej precyzji na wektor liczb zmiennoprzecinkowych pojedynczej precyzji w rejestrze `ymm` [1, 51].
**83. Przekroczenie zakresu liczb całkowitych ze znakiem wskazuje flaga**
a) CF
b) AF
c) SF
d) PF
e) żadna z powyższych
**Poprawna odpowiedź:**
e) żadna z powyższych**  
**Wyjaśnienie:** Przekroczenie zakresu liczb całkowitych ze znakiem jest wskazywane przez flagę `OF` (Overflow Flag), a nie żadną z podanych opcji [52].
**84. Rejestry ymm Intel wprowadził dla zestawu instrukcji**
a) MMX
b) SSE
c) AVX
d) AVX2
e) nie ma takich rejestrów
**Poprawna odpowiedź:**
c) AVX**  
**Wyjaśnienie:** Rejestry `ymm` zostały wprowadzone przez firmę Intel w związku z rozszerzeniem zestawu instrukcji AVX [52, 53].
**85. Ile rejestrów Rnr dodano w trybie 64-bitowym procesorów Intel**
a) 64
b) 8
c) 4
d) 2
e) nie ma takich rejestrów
**Poprawna odpowiedź:**
b) 8**  
**Wyjaśnienie:** W trybie 64-bitowym procesorów Intel dodano 8 nowych rejestrów ogólnego przeznaczenia o nazwach od `r8` do `r15` [53].
**86. Operację przesłania bez użycia pamięci podręcznej w AVX realizuje instrukcja**
a) vmovdqu
b) vmaskmovdqu
c) vpshufhw
d) vmovntdq
e) vpunpcklqdq
**Poprawna odpowiedź:**
d) vmovntdq**  
**Wyjaśnienie:** Instrukcja `vmovntdq` służy do przesyłania danych z rejestrów SIMD do pamięci bez użycia pamięci podręcznej [53].
**87. W którym trybie adresowania wartość argumentu zawiera w**
a) rejestrowym
b) bezpośrednim
c) natychmiastowym
d) we wszystkich powyższych
e) w żadnym z powyższych
**Poprawna odpowiedź:**
c) natychmiastowym**  
**Wyjaśnienie:** W trybie natychmiastowym wartość argumentu jest bezpośrednio zawarta w kodzie instrukcji [54].
**88. Która instrukcja nie zmienia flagi CF**
a) cmpxchg
b) fcomi
c) imul
d) adox
e) wszystkie powyższe
**Poprawna odpowiedź:**
d) adox**  
**Wyjaśnienie:** Instrukcja `adox` sumuje wartości operandu z rejestrem docelowym i modyfikuje flagę `OF`, ale nie zmienia flagi `CF` [55].
**89. Która z instrukcji jest wykorzystywana w trakcie przenoszenia flag C3, C2 i C0 do flag ZF, PF, CF**
a) sahf
b) cmc
c) fclex
d) fldcw
e) fstf
**Poprawna odpowiedź:**
a) sahf**  
**Wyjaśnienie:** Instrukcja `sahf` przenosi zawartość rejestru `ah` do rejestru flag. W połączeniu z `fstsw` (lub `fnstsw`) umożliwia przeniesienie flag koprocesora do flag procesora [55].
**90. Która z instrukcji pozwala na wypełnienie podanym znakiem tekstu**
a) movsd
b) stosw
c) lodsw
d) cmpsb
e) scasb
**Poprawna odpowiedź:**
b) stosw**  
**Wyjaśnienie:** Instrukcja `stosw` przesyła zawartość akumulatora (słowo) do pamięci wskazywanej przez `es:edi`, co może służyć do wypełniania tekstu [56]. Choć dla bajtów byłoby to `stosb`, `stosw` jest jedyną opcją pozwalającą na zapis z rejestru do pamięci w tym kontekście.
**91. Prefiks lock może odnosić się do instrukcji**
a) emms
b) fwait
c) bts
d) cmp
e) cmc
**Poprawna odpowiedź:**
c) bts**  
**Wyjaśnienie:** Prefiks `lock` może odnosić się do instrukcji `bts` (bit test and set) [56, 57].
**92. Ile rejestrów zmm posiadają procesory Intel z rozszerzeniem AVX512**
a) 8
b) 16
c) 32
d) 64
e) nie ma takich rejestrów
**Poprawna odpowiedź:**
c) 32**  
**Wyjaśnienie:** Procesory Intel z rozszerzeniem AVX-512 posiadają 32 rejestry `zmm`, które mają długość 512 bitów [57].
**93. Ile odejmowań można maksymalnie zrealizować dla rejestrów xmm**
a) 64
b) 32
c) 16
d) 8
e) 4
**Poprawna odpowiedź:**
c) 16**  
**Wyjaśnienie:** Rejestry `xmm` mają 128 bitów długości. Maksymalnie można przeprowadzić 16 operacji na 8-bitowych liczbach całkowitych (128/8 = 16) [58].
**94. Operację AVX przesłania najstarszych bitów (bity znaku) każdego bajtu z rejestru ymm1 po kolei do rejestru r32/r64 realizuje instrukcja**
a) vmaskmovdqu
b) vblendd
c) vgatherqq
d) vpmovmskb
e) żadna z powyższych
**Poprawna odpowiedź:**
d) vpmovmskb**  
**Wyjaśnienie:** Instrukcja `vpmovmskb` (Packed Move Mask Bytes) przesyła bity znaku każdego bajtu z rejestru `ymm` do rejestru ogólnego przeznaczenia (`r32`/`r64`) [58].
**95. Która operacja konwertuje liczbę pojedynczej precyzji na liczbę całkowitą**
a) vcvtsd2ss
b) vcvtss2si
c) vcvtpd2ps
d) vcvtsd2si
e) żadna z powyższych
**Poprawna odpowiedź:**
b) vcvtss2si**  
**Wyjaśnienie:** Instrukcja `vcvtss2si` konwertuje wartość zmiennoprzecinkową pojedynczej precyzji z rejestru `xmm` na wartość całkowitą w rejestrze ogólnym [59].
**96. Do ilu bajtów wyrównania adresu wymaga instrukcja vmovapd ymm4, wektor**
a) 2
b) 4
c) 8
d) 16
e) 32
**Poprawna odpowiedź:**
e) 32**  
**Wyjaśnienie:** Instrukcja `vmovapd` (Move Aligned Packed Double) wymaga, aby adres źródłowy lub docelowy był wyrównany do 32 bajtów, ponieważ rejestr `ymm` ma długość 256 bitów (32 bajty) [60].
**97. Która z instrukcji jest poprawna**
a) fild eax
b) fbstp st(2)
c) fdivrp st(3), st
d) fcossin st(1)
e) fsubrp st, st(4)
**Poprawna odpowiedź:**
c) fdivrp st(3), st**  
**Wyjaśnienie:** Instrukcja `fdivrp` wykonuje odwrotną operację dzielenia na rejestrach koprocesora, dzieląc `st(3)` przez `st` i zapisując wynik w `st(3)`, co jest poprawną formą [60, 61].
**98. Która z instrukcji nie zapisuje wyniku porównania we flagach koprocesora**
a) fcom
b) fucomp
c) ficom
d) wszystkie powyższe nie zapisują
e) wszystkie powyższe zapisują
**Poprawna odpowiedź:**
e) wszystkie powyższe zapisują**  
**Wyjaśnienie:** Instrukcje `fcom`, `fucomp` oraz `ficom` wszystkie wykonują porównania liczb zmiennoprzecinkowych i zapisują wyniki w flagach koprocesora (`C0`, `C2`, `C3`) [61].
**99. Która z instrukcji umożliwia całkowitą operację typu: a + b + 3**
a) lea
b) madd
c) addx
d) faddi
e) żadna z powyższych
**Poprawna odpowiedź:**
a) lea**  
**Wyjaśnienie:** Instrukcja `lea` (load effective address) może być wykorzystana do wykonywania operacji arytmetycznych, w tym dodawania stałej wartości do sumy dwóch rejestrów [62].
**100. Która z instrukcji pozwala na wypełnienie tablicy podanym słowem 16-bitowym**
a) cmpsw
b) scasw
c) movsw
d) lodsw
e) żadna z powyższych
**Poprawna odpowiedź:**
e) żadna z powyższych**  
**Wyjaśnienie:** Żadna z wymienionych instrukcji nie służy do wypełniania tablicy podanym słowem. Do tego celu należałoby użyć instrukcji `stosw` [62].
**101. Instrukcja testowa dla kodów nieodpowiadających żadnej instrukcji to**
a) int
b) ud2
c) enter
d) iret
e) nie ma takiej instrukcji
**Poprawna odpowiedź:**
b) ud2**  
**Wyjaśnienie:** Instrukcja `ud2` (undefined instruction) jest specjalnie zaprojektowana do generowania wyjątku dla niepoprawnych lub nieznanych kodów instrukcji [63].
**102. W wybranych procesorach Skylake Intel po raz pierwszy wprowadził**
a) rejestry 64-bitowe
b) pięciostopniowy potok instrukcji
c) instrukcje SSE 4.2
d) dwa rodzaje rdzeni
e) instrukcje AVX512
**Poprawna odpowiedź:**
e) instrukcje AVX512**  
**Wyjaśnienie:** Procesory Skylake w wybranych modelach po raz pierwszy wprowadziły wsparcie dla instrukcji `AVX-512` [63, 64].
**103. Pierwszy procesor hybrydowy Intela to**
a) Sandy Bridge
b) Hashwell
c) Skylake
d) Alder Lake
e) Raptor Lake
**Poprawna odpowiedź:**
d) Alder Lake**  
**Wyjaśnienie:** `Alder Lake` to pierwszy procesor hybrydowy Intela, który wprowadził architekturę z dwoma rodzajami rdzeni: Performance-cores (P-cores) i Efficiency-cores (E-cores) [15, 16, 64].
**104. Która instrukcja może zmienić rejestr cs**
a) xlatb
b) scasw
c) les
d) jmp
e) stc
**Poprawna odpowiedź:**
d) jmp**  
**Wyjaśnienie:** Instrukcja `jmp` (jump) może zmienić rejestr `cs` (Code Segment), ponieważ podczas skoku dalekiego, procesor zmienia zarówno wskaźnik instrukcji (`ip`), jak i segment kodu [65].
**105. Do policzenia młodszych bitów równych 0 służy instrukcja**
a) xgetbv
b) tzcnt
c) lzcnt
d) beztr
e) blsi
**Poprawna odpowiedź:**
b) tzcnt**  
**Wyjaśnienie:** Instrukcja `tzcnt` (trailing zero count) liczy liczbę kolejnych zer zaczynając od najmłodszych bitów (od bitu najmniej znaczącego) [65].
**106. Ile bajtów mieści się w rejestrze r12**
a) 8
b) 16
c) 32
d) 256
e) żadne z powyższych
**Poprawna odpowiedź:**
a) 8**  
**Wyjaśnienie:** Rejestr `r12` jest 64-bitowy, co oznacza, że mieści 8 bajtów (64/8 = 8) [66].
**107. Instrukcja mieszająca bajty z dwóch rejestrów na podstawie trzeciego to**
a) vshufb
b) vpunpcklbw
c) vpackuswb
d) vhaddb
e) vpblendvb
**Poprawna odpowiedź:**
e) vpblendvb**  
**Wyjaśnienie:** Instrukcja `vpblendvb` (Packed Blend Bytes Variable) miesza bajty z dwóch rejestrów źródłowych na podstawie maski zawartej w trzecim rejestrze [67].
**108. Operację AVX obliczającą przybliżoną wartość odwrotności pierwiastka z e elementów wektora liczb rzeczywistych pojedynczej precyzji realizuje instrukcja**
a) vrcpps
b) vrsqrtps
c) vsqrtps
d) vdpps
e) nie ma takiej instrukcji
**Poprawna odpowiedź:**
b) vrsqrtps**  
**Wyjaśnienie:** Instrukcja `vrsqrtps` oblicza przybliżoną wartość odwrotności pierwiastka kwadratowego dla każdego elementu wektora liczb rzeczywistych pojedynczej precyzji [67].
**109. Która operacja konwertuje liczbę podwójnej precyzji na liczbę pojedynczej precyzji**
a) vcvtsd2ss
b) vcvtps2pd
c) vcvtpd2ps
d) vcvtsi2ss
e) żadna z powyższych
**Poprawna odpowiedź:**
a) vcvtsd2ss**  
**Wyjaśnienie:** Instrukcja `vcvtsd2ss` konwertuje liczbę zmiennoprzecinkową podwójnej precyzji na liczbę zmiennoprzecinkową pojedynczej precyzji [68].
**110. Podczas odejmowania skalarów z rejestrów wektorowych xmm pozostałe elementy celu**
a) są zerowane
b) pozostają bez zmiany
c) pochodzą ze źródła 1
d) pochodzą ze źródła 2
e) są niezdefiniowane
**Poprawna odpowiedź:**
a) są zerowane**  
**Wyjaśnienie:** Podczas wykonywania operacji odejmowania skalarów na rejestrze wektorowym, pozostałe elementy celu, nieobjęte operacją, zostają wyzerowane [68].
**111. Podczas dodawania skalarów z rejestrów wektorowych pozostałe elementy celu**
a) pozostają bez zmiany
b) pochodzą ze źródła 1
c) pochodzą ze źródła 2
d) są zerowane
e) są niezdefiniowane
**Poprawna odpowiedź:**
d) są zerowane**  
**Wyjaśnienie:** Podczas wykonywania operacji dodawania skalarów na rejestrach wektorowych, pozostałe elementy celu, nieobjęte operacją, zostają wyzerowane [68].
**112. Do policzenia starszych bitów równych 0 służy instrukcja**
a) bsf
b) lzcnt
c) btr
d) beztr
e) rdtsc
**Poprawna odpowiedź:**
b) lzcnt**  
**Wyjaśnienie:** Instrukcja `lzcnt` służy do liczenia liczby wiodących (starszych) bitów równych 0 w liczbie zapisanej w rejestrze [35].
**113. Która instrukcja zapisuje do dwu rejestrów**
a) les
b) xlatb
c) movsd
d) btr
e) żadna z powyższych
**Poprawna odpowiedź:**
a) les**  
**Wyjaśnienie:** Instrukcja `les` (load ES and pointer) ładuje dane do dwóch rejestrów: rejestru ogólnego przeznaczenia oraz rejestru segmentowego `es` [27, 35].
**114. Która instrukcja może zmienić rejestr cs**
a) xlatb
b) call
c) les
d) jnz
e) stc
**Poprawna odpowiedź:**
b) call**  
**Wyjaśnienie:** Instrukcja `call` zmienia zarówno rejestr `ip`, jak i rejestr `cs`. To oznacza, że wywołanie dalekie może przenieść wykonanie programu do innego segmentu kodu, zmieniając wartość rejestru `cs` [27].
**115. Do wydobycia najmłodszego bitu równego 1 służy instrukcja**
a) xgetbv
b) lzcnt
c) hextr
d) tzcnt
e) blsi
**Poprawna odpowiedź:**
e) blsi**  
**Wyjaśnienie:** Instrukcja `blsi` służy do wydobycia najmłodszego bitu ustawionego na 1, zerując wszystkie inne bity [15].
**116. Pierwszy procesor wielordzeniowy Intela to**
a) i486
b) Pentium II
c) Pentium 4
d) Sandy Bridge
e) Hashwell
**Poprawna odpowiedź:**
c) Pentium 4**  
**Wyjaśnienie:** Procesor `Pentium 4` był pierwszym procesorem Intela z dwoma rdzeniami, wprowadzonym w 2005 roku [15].
**117. W procesorze Alder Lake Intel po raz pierwszy wprowadził**
a) rejestry 64-bitowe
b) pięciostopniowy potok instrukcji
c) koprocesor matematyczny
d) dwa rodzaje rdzeni
e) generator liczb losowych
**Poprawna odpowiedź:**
d) dwa rodzaje rdzeni**  
**Wyjaśnienie:** Procesor `Alder Lake` to pierwszy procesor Intela, który wprowadził hybrydową architekturę z dwoma rodzajami rdzeni: Performance-cores (P-cores) i Efficiency-cores (E-cores) [15, 16].
**118. Przerwanie programowe wywołuje instrukcja**
a) int
b) call
c) enter
d) iret
e) żadne z powyższych
**Poprawna odpowiedź:**
a) int**  
**Wyjaśnienie:** Instrukcja `int` służy do wywołania przerwania programowego. Pozwala na przekazywanie sterowania do odpowiedniej procedury obsługi przerwań [70].
**119. Która instrukcja dla liczb ze znakiem zamienia słowo na podwójne słowo**
a) movzx
b) cbw
c) cwde
d) xlatb
e) bswap
**Poprawna odpowiedź:**
c) cwde**  
**Wyjaśnienie:** Instrukcja `cwde` (convert word to doubleword extended) zamienia zawartość rejestru `ax` na `eax`, rozszerzając słowo do podwójnego słowa z zachowaniem znaku liczby [70].
**120. Operację zamiany słów na poczwórne słowa realizuje instrukcja**
a) vpackssdw
b) vmaskmovdqu
c) vpunpckldq
d) vpermsq
e) vmovsxwq
**Poprawna odpowiedź:**
c) vpunpckldq**  
**Wyjaśnienie:** Instrukcja `vpunpckldq` rozpakowuje i zamienia 32-bitowe słowa na 64-bitowe poczwórne słowa, przeplatając dane z dwóch rejestrów źródłowych [70, 71].
**121. Operację AVX odczytu danych z podanych dowolnych elementów tablicy realizuje instrukcja**
a) vpermq
b) vblendd
c) vgatherps
d) vgatherdps
e) żadna z powyższych
**Poprawna odpowiedź:**
e) żadna z powyższych**  
**Wyjaśnienie:** Do odczytu danych z podanych dowolnych elementów tablicy służy instrukcja `vgatherqq`, która nie jest wymieniona wśród opcji [71, 72].
**122. Tryb prosty adresowania występuje w instrukcji**
a) inc ecx
b) mov edi, offset zmienna
c) mov zmienna, edx
d) or edx, [ebx]
e) mov [edi * 8 + tablica], edx
**Poprawna odpowiedź:**
b) mov edi, offset zmienna**  
**Wyjaśnienie:** W trybie prostym (natychmiastowym) operandem jest stała wartość, jak w przypadku instrukcji `mov edi, offset zmienna`, gdzie adres jest przekazywany bezpośrednio [25, 72].
**123. Po wykonaniu instrukcji: mov eax, 0f0f00f0fh, mov edx, 87654321h, not ax, add dx, 7, add edx, eax rejestr edx będzie zawierał**
a) 80604020h
b) 07070301h
c) 07054020h
d) 00600301h
e) 07054022h
**Poprawna odpowiedź:** **Pytanie błędne.**  
**Wyjaśnienie:** Źródło wyraźnie wskazuje, że "Błędne zadanie, poprawna odpwiedź to: 78563418h" [72]. Ponieważ prawidłowa odpowiedź nie znajduje się wśród opcji, pytanie jest uznane za błędne.
**124. Po wykonaniu której instrukcji zawartość al zmieni się z 0c9h na 36h**
a) or al, 36h
b) not al
c) rcl al, 1
d) sal, al, 1
e) mov 36h, al
**Poprawna odpowiedź:**
b) not al**  
**Wyjaśnienie:** Wartość `0c9h` binarnie to `11001001`. Instrukcja `not al` neguje wszystkie bity, co daje `00110110` (czyli `36h`) [73].
**125. Po wykonaniu instrukcji: mov edx, 0f459a01h, bswap edx rejestr edx będzie zawierał**
a) 0f459a01h
b) 9a010f45h
c) 10a954f0h
d) 019a450fh
e) żadne z powyższych
**Poprawna odpowiedź:**
d) 019a450fh**  
**Wyjaśnienie:** Instrukcja `bswap edx` zamienia kolejność bajtów w 32-bitowym rejestrze `edx`. Wartość `0f459a01h` po zamianie bajtów staje się `019a450fh` [73].
**126. Po wykonaniu instrukcji: mov eax, 0f0f0f0fh, mov edx, 12345678h, not ax, inc dx, and edx, eax**
a) 02045070h
b) 12345678h
c) 10300609h
d) 02040608h
e) 02040609h
**Poprawna odpowiedź:**
a) 02045070h**  
**Wyjaśnienie:**
1.  `eax` = `0f0f0f0fh`
2.  `edx` = `12345678h`
3.  `not ax` zmienia `ax` (`0f0fh`) na `f0f0h`, więc `eax` = `0f0ff0f0h` [74].
4.  `inc dx` zmienia `dx` (`5678h`) na `5679h`, więc `edx` = `12345679h` [74].
5.  `and edx, eax` ( `12345679h` AND `0f0ff0f0h`) daje `02045070h` [74].
**127. Która z instrukcji dla liczb ze znakiem zamienia bajt na podwójne słowo**
a) movsx
b) cbw
c) cwde
d) xlatb
e) bswap
**Poprawna odpowiedź:**
a) movsx**  
**Wyjaśnienie:** Instrukcja `movsx` (move with sign extend) kopiuje wartość źródłową (np. bajt) i rozszerza ją do większego rozmiaru (np. podwójnego słowa) z zachowaniem znaku [74].
**128. Ile operacji na bajtach może wykonać jedna instrukcja MMX**
a) 4
b) 8
c) 16
d) 32
e) 64
**Poprawna odpowiedź:**
b) 8**  
**Wyjaśnienie:** Rejestry MMX mają długość 64 bitów, co pozwala na wykonywanie 8 operacji na bajtach jednocześnie (64/8 = 8) [75].
**129. Po wykonaniu instrukcji: mov eax, 0f0f00f0fh, mov edx, 87654321h, rol ax, 4, add dx, 7, and edx, eax**
a) 80604020h
b) 07050301h
c) 07054020h
d) 07004028h
e) 07654320h
**Poprawna odpowiedź:**
a) 80604020h**  
**Wyjaśnienie:**
1.  `eax` = `0f0f00f0fh`
2.  `edx` = `87654321h`
3.  `rol ax, 4` zmienia `ax` (`00f0h`) na `0f00h`, więc `eax` = `0f0f0f00h` [75].
4.  `add dx, 7` zmienia `dx` (`4321h`) na `4328h`, więc `edx` = `87654328h` [75].
5.  `and edx, eax` ( `87654328h` AND `0f0f0f00h`) daje `80604020h` [75].
**130. Po wykonaniu instrukcji: mov edx, 1000h, bsf eax, edx rejestr eax będzie zawierał**
a) 00000004h
b) 0000000ch
c) 00000012h
d) 01000000h
e) żadna z powyższych
**Poprawna odpowiedź:**
b) 0000000ch**  
**Wyjaśnienie:** Instrukcja `bsf` (bit scan forward) szuka pierwszego bitu ustawionego na 1. Wartość `1000h` binarnie to `...0001 0000 0000 0000b`. Pierwszy ustawiony bit znajduje się na pozycji 12, więc do `eax` zostanie wpisana wartość `12`, co w heksadecymalnym zapisie odpowiada `0000000ch` [76].
**131. Prefiks lock może odnosić się do instrukcji**
a) nop
b) adc
c) cmp
d) cmc
e) fwait
**Poprawna odpowiedź:**
b) adc**  
**Wyjaśnienie:** Prefiks `lock` może odnosić się do instrukcji `adc` (add with carry) [4, 38].
**132. Która z instrukcji dla liczb bez znaku przesyła dla warunku większości**
a) movg
b) movae
c) cmovnle
d) cmovnbe
e) cmpa
**Poprawna odpowiedź:**
d) cmovnbe**  
**Wyjaśnienie:** Dla liczb bez znaku, warunek "większości" (`above`) odpowiada warunkowi "nie mniejsze lub równe" (`nbe`), co realizuje instrukcja `cmovnbe` [4].
**133. Ile rejestrów ymm posiadają w trybie EM64T procesory Intel**
a) 8
b) 16
c) 32
d) 64
e) nie ma takich rejestrów
**Poprawna odpowiedź:**
b) 16**  
**Wyjaśnienie:** W 64-bitowej architekturze Intel (tryb EM64T), procesory posiadają 16 rejestrów `ymm` (od `YMM0` do `YMM15`) [4, 77].